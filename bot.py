import json
import logging
import requests
from telegram import (
    Update, KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove
)
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, ConversationHandler, ContextTypes
)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è MTT API
MTT_API_URL = "https://api.mtt.ru/v1"
MTT_API_KEY = "your_mtt_api_key"
MTT_CALLER_ID = "79876543210"  # –í–∞—à –Ω–æ–º–µ—Ä –≤ —Ñ–æ—Ä–º–∞—Ç–µ 79...
GATE_PHONE_NUMBER = "79876543210"  # –ù–æ–º–µ—Ä —à–ª–∞–≥–±–∞—É–º–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ 79...

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –°–æ—Å—Ç–æ—è–Ω–∏—è
ASK_PHONE, MAIN_MENU = range(2)

# –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
try:
    with open("users.json", "r", encoding='utf-8') as f:
        USERS = json.load(f)
except FileNotFoundError:
    logger.error("–§–∞–π–ª users.json –Ω–µ –Ω–∞–π–¥–µ–Ω")
    USERS = {}
except json.JSONDecodeError:
    logger.error("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è users.json")
    USERS = {}

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
CHAT_LINK = "https://t.me/+your_chat_link_here"
PAYMENT_LINK = "https://your-payment-link"
REKVIZITY = "–†–µ–∫–≤–∏–∑–∏—Ç—ã –°–ù–¢ ¬´–ü–æ–±–µ–¥–∞¬ª:\n–ò–ù–ù: –•–•–•–•–•–•\n–ë–ò–ö: –•–•–•–•–•–•\n..."

# –§—É–Ω–∫—Ü–∏—è –∑–≤–æ–Ω–∫–∞ —á–µ—Ä–µ–∑ MTT API
def call_gate_via_mtt():
    """–°–æ–≤–µ—Ä—à–µ–Ω–∏–µ –∑–≤–æ–Ω–∫–∞ —á–µ—Ä–µ–∑ API –ú–¢–¢"""
    try:
        headers = {
            "Authorization": f"Bearer {MTT_API_KEY}",
            "Content-Type": "application/json"
        }
        
        # –î–∞–Ω–Ω—ã–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∑–≤–æ–Ω–∫–∞
        call_data = {
            "caller_id": MTT_CALLER_ID,
            "callee_number": GATE_PHONE_NUMBER,
            "max_duration": 30,  # –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–≤–æ–Ω–∫–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
            "auto_answer": True  # –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø—Ä–∏–Ω—è—Ç–∏–µ –≤—ã–∑–æ–≤–∞
        }
        
        response = requests.post(
            f"{MTT_API_URL}/calls",
            json=call_data,
            headers=headers,
            timeout=10
        )
        
        if response.status_code == 200:
            call_info = response.json()
            logger.info(f"MTT call initiated: CallID={call_info.get('call_id')}")
            return True
        else:
            logger.error(f"MTT API error: {response.status_code} - {response.text}")
            return False
            
    except Exception as e:
        logger.error(f"MTT call failed: {e}")
        return False

# –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç —á–µ—Ä–µ–∑ Zadarma API
def call_gate_via_zadarma():
    """–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ Zadarma API"""
    try:
        api_key = "your_zadarma_api_key"
        secret_key = "your_zadarma_secret"
        
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ–¥–ø–∏—Å–∏ –¥–ª—è API
        import hashlib
        import hmac
        import time
        
        current_time = str(int(time.time()))
        sign_string = current_time + secret_key
        signature = hmac.new(secret_key.encode(), sign_string.encode(), hashlib.sha1).hexdigest()
        
        headers = {
            "Authorization": f"{api_key}:{signature}",
            "Content-Type": "application/json"
        }
        
        call_data = {
            "from": MTT_CALLER_ID,  # –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ –Ω–æ–º–µ—Ä
            "to": GATE_PHONE_NUMBER,
            "predicted": "auto"  # –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–æ–º–µ—Ä–∞
        }
        
        response = requests.post(
            "https://api.zadarma.com/v1/request/callback/",
            json=call_data,
            headers=headers,
            timeout=10
        )
        
        if response.status_code == 200:
            logger.info("Zadarma call initiated successfully")
            return True
        else:
            logger.error(f"Zadarma API error: {response.status_code} - {response.text}")
            return False
            
    except Exception as e:
        logger.error(f"Zadarma call failed: {e}")
        return False

# –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç —á–µ—Ä–µ–∑ –ø—Ä–æ—Å—Ç–æ–π SIP-–∑–≤–æ–Ω–æ–∫
def call_gate_via_sip():
    """–ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ SIP (–¥–ª—è Asterisk/Freeswitch)"""
    try:
        # –î–∞–Ω–Ω—ã–µ –¥–ª—è –≤–∞—à–µ–π SIP-–ê–¢–°
        sip_server = "your_sip_server.com"
        sip_username = "your_sip_username"
        sip_password = "your_sip_password"
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É pjsua2 –¥–ª—è SIP-–∑–≤–æ–Ω–∫–æ–≤
        try:
            import pjsua2 as pj
            
            # –°–æ–∑–¥–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç
            acc_cfg = pj.AccountConfig()
            acc_cfg.idUri = f"sip:{sip_username}@{sip_server}"
            acc_cfg.regConfig.registrarUri = f"sip:{sip_server}"
            acc_cfg.sipConfig.authCreds.append(
                pj.AuthCredInfo("digest", "*", sip_username, 0, sip_password)
            )
            
            # –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ SIP-–∑–≤–æ–Ω–∫–∞
            # –≠—Ç–æ —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø—Ä–∏–º–µ—Ä - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–ª–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ PJSUA2
            
            logger.info("SIP call configured")
            return True
            
        except ImportError:
            logger.warning("pjsua2 not available, using fallback")
            # Fallback: –æ—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–∞–Ω–¥—ã –Ω–∞ SIP-—Å–µ—Ä–≤–µ—Ä —á–µ—Ä–µ–∑ HTTP API
            sip_data = {
                "extension": "100",  # –Ω–æ–º–µ—Ä –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –∞–±–æ–Ω–µ–Ω—Ç–∞
                "number": GATE_PHONE_NUMBER,
                "callerid": MTT_CALLER_ID
            }
            
            response = requests.post(
                f"http://{sip_server}/api/call",
                json=sip_data,
                auth=(sip_username, sip_password),
                timeout=10
            )
            
            if response.status_code == 200:
                logger.info("SIP call initiated via HTTP API")
                return True
            else:
                return False
                
    except Exception as e:
        logger.error(f"SIP call failed: {e}")
        return False

async def fake_call_gate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ –∑–≤–æ–Ω–∫–∞ –Ω–∞ –≤–æ—Ä–æ—Ç–∞"""
    await update.message.reply_text("üìû –ó–≤–æ–Ω—é –Ω–∞ –≤–æ—Ä–æ—Ç–∞...")
    
    # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –ø–æ –ø–æ—Ä—è–¥–∫—É
    success = call_gate_via_mtt()
    
    # –ï—Å–ª–∏ MTT –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø—Ä–æ–±—É–µ–º Zadarma
    if not success:
        logger.info("Trying Zadarma as fallback...")
        success = call_gate_via_zadarma()
    
    # –ï—Å–ª–∏ –∏ Zadarma –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø—Ä–æ–±—É–µ–º SIP
    if not success:
        logger.info("Trying SIP as fallback...")
        success = call_gate_via_sip()
    
    if success:
        await update.message.reply_text("‚úÖ –í–æ—Ä–æ—Ç–∞ –æ—Ç–∫—Ä—ã–≤–∞—é—Ç—Å—è. –ó–≤–æ–Ω–æ–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.")
    else:
        await update.message.reply_text(
            "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–≤–æ–Ω–∫–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.\n"
            "–ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø—Ä–µ–¥—Å–µ–¥–∞—Ç–µ–ª–µ–º –°–ù–¢."
        )

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ù–∞—á–∞–ª–æ —Ä–∞–±–æ—Ç—ã —Å –±–æ—Ç–æ–º"""
    contact_button = KeyboardButton("–ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º", request_contact=True)
    reply_markup = ReplyKeyboardMarkup([[contact_button]], resize_keyboard=True)
    await update.message.reply_text(
        "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Å–≤–æ–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞:",
        reply_markup=reply_markup
    )
    return ASK_PHONE

async def ask_phone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞"""
    contact = update.message.contact
    if not contact:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É.")
        return ASK_PHONE
    
    phone = contact.phone_number

    if not phone.startswith("+"):
        phone = "+" + phone  # —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º

    if phone in USERS:
        USERS[phone]["telegram_id"] = update.effective_user.id
        context.user_data["phone"] = phone
        await update.message.reply_text(
            f"–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, {USERS[phone]['name']}!",
            reply_markup=ReplyKeyboardRemove()
        )
        return await show_main_menu(update, context)
    else:
        await update.message.reply_text(
            "–í–∞—à –Ω–æ–º–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –°–ù–¢. –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.",
            reply_markup=ReplyKeyboardRemove()
        )
        return ConversationHandler.END

async def show_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–∫–∞–∑–∞—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"""
    menu = [
        ["üí∞ –í–∑–Ω–æ—Å—ã", "üì∞ –ù–æ–≤–æ—Å—Ç–∏"],
        ["üí¨ –ß–∞—Ç", "üö™ –û—Ç–∫—Ä—ã—Ç—å –≤–æ—Ä–æ—Ç–∞"],
        ["‚ö†Ô∏è –î–æ–ª–∂–Ω–∏–∫–∏"]
    ]
    reply_markup = ReplyKeyboardMarkup(menu, resize_keyboard=True)
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª:", reply_markup=reply_markup)
    return MAIN_MENU

async def handle_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –≤ –º–µ–Ω—é"""
    text = update.message.text

    if text == "üí∞ –í–∑–Ω–æ—Å—ã":
        msg = (f"üí∞ *–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–∑–Ω–æ—Å–∞—Ö 2025 –≥–æ–¥–∞:*\n"
               f"- –ß–ª–µ–Ω—Å–∫–∏–π: 5000‚ÇΩ\n"
               f"- –¶–µ–ª–µ–≤–æ–π: 3000‚ÇΩ\n\n"
               f"{REKVIZITY}\n\n"
               f"[–ü–µ—Ä–µ–π—Ç–∏ –∫ –æ–ø–ª–∞—Ç–µ]({PAYMENT_LINK})")
        await update.message.reply_markdown(msg)
    
    elif text == "üì∞ –ù–æ–≤–æ—Å—Ç–∏":
        try:
            with open("data/news.txt", "r", encoding="utf-8") as f:
                news = f.read()
            await update.message.reply_text(f"üì∞ –ü–æ—Å–ª–µ–¥–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–∏ –°–ù–¢:\n\n{news}")
        except FileNotFoundError:
            await update.message.reply_text("üì∞ –ù–æ–≤–æ—Å—Ç–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.")
    
    elif text == "üí¨ –ß–∞—Ç":
        await update.message.reply_text(f"üí¨ –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ —á–∞—Ç –°–ù–¢: {CHAT_LINK}")
    
    elif text == "üö™ –û—Ç–∫—Ä—ã—Ç—å –≤–æ—Ä–æ—Ç–∞":
        await fake_call_gate(update, context)
    
    elif text == "‚ö†Ô∏è –î–æ–ª–∂–Ω–∏–∫–∏":
        try:
            with open("data/debtors.txt", "r", encoding="utf-8") as f:
                debtors = f.read()
            await update.message.reply_text(f"‚ö†Ô∏è –î–æ–ª–∂–Ω–∏–∫–∏ –°–ù–¢:\n\n{debtors}")
        except FileNotFoundError:
            await update.message.reply_text("‚ö†Ô∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–æ–ª–∂–Ω–∏–∫–∞—Ö –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.")
    
    else:
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª –∏–∑ –º–µ–Ω—é.")
    
    return MAIN_MENU

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –¥–∏–∞–ª–æ–≥–∞"""
    await update.message.reply_text("–î–æ —Å–≤–∏–¥–∞–Ω–∏—è!", reply_markup=ReplyKeyboardRemove())
    return ConversationHandler.END

def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞"""
    # –ó–∞–º–µ–Ω–∏—Ç–µ "YOUR_BOT_TOKEN" –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω –≤–∞—à–µ–≥–æ –±–æ—Ç–∞
    app = Application.builder().token("YOUR_BOT_TOKEN").build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            ASK_PHONE: [MessageHandler(filters.CONTACT, ask_phone)],
            MAIN_MENU: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_menu)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    app.add_handler(conv_handler)
    logger.info("Bot is running...")
    app.run_polling()

if __name__ == "__main__":
    main()
